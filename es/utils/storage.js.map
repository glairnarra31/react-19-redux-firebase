{"version":3,"file":"storage.js","names":["FILE_UPLOAD_ERROR","actionTypes","FILE_UPLOAD_PROGRESS","deleteFile","firebase","_ref","path","dbPath","storage","ref","delete","then","database","firestore","metaDeletePromise","_","config","useFirestoreForStorageMeta","doc","remove","createUploadMetaResponseHandler","_ref2","fileData","uploadTaskSnapshot","downloadURL","metaDataSnapshot","result","snapshot","key","id","File","uploadTaskSnaphot","createdAt","FieldValue","serverTimestamp","ServerValue","TIMESTAMP","getDownloadURLFromUploadTaskSnapshot","getDownloadURL","Promise","resolve","downloadURLs","writeMetadataToDb","_ref3","options","_firebase$_$config","fileMetadataFactory","metadataFactory","documentId","useSetForMetadata","metaFactoryFunction","metadata","_omitBy2","default","_isUndefined2","resultFromSnap","documentIdFromOptions","metaSetPromise","docRef","collection","update","set","merge","add","newMetaRef","push","uploadFileWithProgress","dispatch","_ref4","file","filename","meta","fileMetadata","uploadEvent","concat","put","unListen","on","TaskEvent","STATE_CHANGED","next","type","payload","percent","Math","floor","bytesTransferred","totalBytes","error","err","complete"],"sources":["../../src/utils/storage.js"],"sourcesContent":["import { omitBy, isUndefined } from 'lodash'\nimport { actionTypes } from '../constants'\n\nconst { FILE_UPLOAD_ERROR, FILE_UPLOAD_PROGRESS } = actionTypes\n\n/**\n * Delete file from Firebase Storage with support for deleteing meta\n * data from database (either Real Time Database or Firestore depending on\n * config)\n * @param {object} firebase - Internal firebase object\n * @param {object} settings - Settings object\n * @param {string} settings.path - Path to File which should be deleted\n * @param {string} settings.dbPath - Path of meta data with Database (Real Time Or\n * Firestore depnding on config)\n * @returns {Promise} Resolves with path and dbPath\n */\nexport function deleteFile(firebase, { path, dbPath }) {\n  return firebase\n    .storage()\n    .ref(path)\n    .delete()\n    .then(() => {\n      // return path if dbPath or a database does not exist\n      if (!dbPath || (!firebase.database && !firebase.firestore)) {\n        return { path }\n      }\n\n      // Choose delete function based on config (Handling Firestore and RTDB)\n      const metaDeletePromise = () =>\n        firebase._.config.useFirestoreForStorageMeta\n          ? firebase.firestore().doc(dbPath).delete() // file meta in Firestore\n          : firebase.database().ref(dbPath).remove() // file meta in RTDB\n\n      return metaDeletePromise().then(() => ({ path, dbPath }))\n    })\n}\n\n/**\n * Create a function to handle response from upload.\n * @param {object} settings - Settings object\n * @param {object} settings.fileData - File data which was uploaded\n * @param {object} settings.uploadTaskSnapshot - Snapshot from storage upload task\n * @param {object} settings.firebase - Firebase instance\n * @param {string} settings.downloadURL - Download url\n * @returns {Function} Function for handling upload result\n */\nfunction createUploadMetaResponseHandler({\n  fileData,\n  firebase,\n  uploadTaskSnapshot,\n  downloadURL\n}) {\n  /**\n   * Converts upload meta data snapshot into an object (handling both\n   * RTDB and Firestore)\n   * @param  {object} metaDataSnapshot - Snapshot from metadata upload (from\n   * RTDB or Firestore)\n   * @returns {object} Upload result including snapshot, key, File\n   */\n  return function uploadResultFromSnap(metaDataSnapshot) {\n    const { useFirestoreForStorageMeta } = firebase._.config\n    const result = {\n      snapshot: metaDataSnapshot,\n      key: metaDataSnapshot.key || metaDataSnapshot.id,\n      File: fileData,\n      metaDataSnapshot,\n      uploadTaskSnapshot,\n      // Support legacy method\n      uploadTaskSnaphot: uploadTaskSnapshot,\n      createdAt: useFirestoreForStorageMeta\n        ? firebase.firestore.FieldValue.serverTimestamp()\n        : firebase.database.ServerValue.TIMESTAMP\n    }\n    // Attach id if it exists (Firestore)\n    if (metaDataSnapshot.id) {\n      result.id = metaDataSnapshot.id\n    }\n    // Attach downloadURL if it exists\n    if (downloadURL) {\n      result.downloadURL = downloadURL\n    }\n    return result\n  }\n}\n\n/**\n * Get download URL from upload task snapshot\n * @param {firebase.storage.UploadTaskSnapshot} uploadTaskSnapshot - Upload task snapshot\n * @returns {Promise} Resolves with download URL\n */\nfunction getDownloadURLFromUploadTaskSnapshot(uploadTaskSnapshot) {\n  // Handle different downloadURL patterns (Firebase JS SDK v5.*.* vs v4.*.*)\n  if (\n    uploadTaskSnapshot.ref &&\n    typeof uploadTaskSnapshot.ref.getDownloadURL === 'function'\n  ) {\n    // Get downloadURL and attach to response\n    return uploadTaskSnapshot.ref.getDownloadURL()\n  }\n  // Only attach downloadURL if downloadURLs is defined (not defined in v5.*.*)\n  return Promise.resolve(\n    uploadTaskSnapshot.downloadURLs && uploadTaskSnapshot.downloadURLs[0]\n  )\n}\n\n/**\n * Write file metadata to Database (either Real Time Datbase or Firestore\n * depending on config).\n * @param {object} settings - Settings object\n * @param {object} settings.firebase - Internal firebase object\n * @param {object} settings.uploadTaskSnapshot - Snapshot from upload task\n * @param {string} settings.dbPath - Path of meta data with Database (Real Time Or\n * Firestore depnding on config)\n * @param {object} settings.options - Options object\n * @returns {Promise} Resolves with payload (includes snapshot, File, and\n * metaDataSnapshot)\n */\nexport function writeMetadataToDb({\n  firebase,\n  uploadTaskSnapshot,\n  dbPath,\n  options\n}) {\n  // Support metadata factories from both global config and options\n  const { fileMetadataFactory, useFirestoreForStorageMeta } = firebase._.config\n  const { metadataFactory, documentId, useSetForMetadata } = options\n  const metaFactoryFunction = metadataFactory || fileMetadataFactory\n  // Get download URL for use in metadata write\n  return getDownloadURLFromUploadTaskSnapshot(uploadTaskSnapshot).then(\n    (downloadURL) => {\n      // Apply fileMetadataFactory if it exists in config\n      const fileData =\n        typeof metaFactoryFunction === 'function'\n          ? metaFactoryFunction(\n              uploadTaskSnapshot,\n              firebase,\n              uploadTaskSnapshot.metadata,\n              downloadURL\n            )\n          : omitBy(uploadTaskSnapshot.metadata, isUndefined)\n\n      // Create the snapshot handler function\n      const resultFromSnap = createUploadMetaResponseHandler({\n        fileData,\n        firebase,\n        uploadTaskSnapshot,\n        downloadURL\n      })\n\n      // Function for creating promise for writing file metadata (handles writing to RTDB or Firestore)\n      const documentIdFromOptions =\n        typeof documentId === 'function'\n          ? documentId(\n              uploadTaskSnapshot,\n              firebase,\n              uploadTaskSnapshot.metadata,\n              downloadURL\n            )\n          : documentId\n      const metaSetPromise = (fileData) => {\n        if (useFirestoreForStorageMeta) {\n          if (documentIdFromOptions) {\n            const docRef = firebase // Write metadata to Firestore\n              .firestore()\n              .collection(dbPath)\n              .doc(documentIdFromOptions)\n            return useSetForMetadata === false\n              ? docRef.update(fileData).then(() => docRef)\n              : docRef.set(fileData, { merge: true }).then(() => docRef)\n          }\n          return firebase.firestore().collection(dbPath).add(fileData)\n        }\n        // Create new reference for metadata\n        const newMetaRef = firebase.database().ref(dbPath).push()\n        // Write metadata to Real Time Database and return new meta ref\n        return newMetaRef.set(fileData).then((res) => newMetaRef)\n      }\n\n      return metaSetPromise(fileData).then(resultFromSnap)\n    }\n  )\n}\n\n/**\n * Upload a file with actions fired for progress, success, and errors\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {object} opts - File data object\n * @param {object} opts.path - Location within Firebase Stroage at which to upload file.\n * @param {Blob} opts.file - File to upload\n * @param {object} opts.fileMetadata - Metadata to pass along to storageRef.put call\n * @param {object} opts.meta - Meta object\n * @returns {Promise} Promise which resolves after file upload\n * @private\n */\nexport function uploadFileWithProgress(\n  dispatch,\n  firebase,\n  { path, file, filename, meta, fileMetadata }\n) {\n  const uploadEvent = firebase\n    .storage()\n    .ref(`${path}/${filename}`)\n    .put(file, fileMetadata)\n\n  const unListen = uploadEvent.on(firebase.storage.TaskEvent.STATE_CHANGED, {\n    next: (snapshot) => {\n      dispatch({\n        type: FILE_UPLOAD_PROGRESS,\n        meta,\n        payload: {\n          snapshot,\n          percent: Math.floor(\n            (snapshot.bytesTransferred / snapshot.totalBytes) * 100\n          )\n        }\n      })\n    },\n    error: (err) => {\n      dispatch({ type: FILE_UPLOAD_ERROR, meta, payload: err })\n      unListen()\n    },\n    complete: () => {\n      unListen()\n    }\n  })\n  return uploadEvent\n}\n"],"mappings":"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","ignoreList":[]}